// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: iterations.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createIteration = `-- name: CreateIteration :one
INSERT INTO session_iterations (
    id,
    session_id,
    iteration_number,
    title
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, session_id, iteration_number, title, created_at
`

type CreateIterationParams struct {
	ID              pgtype.UUID `json:"id"`
	SessionID       pgtype.UUID `json:"session_id"`
	IterationNumber int32       `json:"iteration_number"`
	Title           string      `json:"title"`
}

func (q *Queries) CreateIteration(ctx context.Context, arg CreateIterationParams) (SessionIteration, error) {
	row := q.db.QueryRow(ctx, createIteration,
		arg.ID,
		arg.SessionID,
		arg.IterationNumber,
		arg.Title,
	)
	var i SessionIteration
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.IterationNumber,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

type CreateIterationsParams struct {
	ID              pgtype.UUID `json:"id"`
	SessionID       pgtype.UUID `json:"session_id"`
	IterationNumber int32       `json:"iteration_number"`
	Title           string      `json:"title"`
}

const getCurrentIteration = `-- name: GetCurrentIteration :one
SELECT si.id, si.session_id, si.iteration_number, si.title, si.created_at FROM session_iterations as si
JOIN sessions as ss on ss.id = si.session_id
WHERE si.session_id = $1 AND si.iteration_number = ss.current_iteration
LIMIT 1
`

func (q *Queries) GetCurrentIteration(ctx context.Context, sessionID pgtype.UUID) (SessionIteration, error) {
	row := q.db.QueryRow(ctx, getCurrentIteration, sessionID)
	var i SessionIteration
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.IterationNumber,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const getIterationByID = `-- name: GetIterationByID :one
SELECT id, session_id, iteration_number, title, created_at FROM session_iterations
WHERE id = $1
`

func (q *Queries) GetIterationByID(ctx context.Context, id pgtype.UUID) (SessionIteration, error) {
	row := q.db.QueryRow(ctx, getIterationByID, id)
	var i SessionIteration
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.IterationNumber,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const getNextIteration = `-- name: GetNextIteration :one
SELECT si.id, si.session_id, si.iteration_number, si.title, si.created_at FROM session_iterations as si
JOIN sessions as ss on ss.id = si.session_id
WHERE si.session_id = $1 AND si.iteration_number = ss.current_iteration + 1
LIMIT 1
`

func (q *Queries) GetNextIteration(ctx context.Context, sessionID pgtype.UUID) (SessionIteration, error) {
	row := q.db.QueryRow(ctx, getNextIteration, sessionID)
	var i SessionIteration
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.IterationNumber,
		&i.Title,
		&i.CreatedAt,
	)
	return i, err
}

const listIterationsBySession = `-- name: ListIterationsBySession :many
SELECT id, session_id, iteration_number, title, created_at FROM session_iterations
WHERE session_id = $1
ORDER BY iteration_number ASC
`

func (q *Queries) ListIterationsBySession(ctx context.Context, sessionID pgtype.UUID) ([]SessionIteration, error) {
	rows, err := q.db.Query(ctx, listIterationsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SessionIteration{}
	for rows.Next() {
		var i SessionIteration
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.IterationNumber,
			&i.Title,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
