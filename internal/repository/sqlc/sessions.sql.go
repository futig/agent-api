// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: sessions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const aquireSessionByID = `-- name: AquireSessionByID :one
UPDATE sessions
SET status = 'Processing', 
    updated_at = NOW()
WHERE id = $1 AND status = 'WaitingForAnswers'
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

func (q *Queries) AquireSessionByID(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, aquireSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createFilledSession = `-- name: CreateFilledSession :one
INSERT INTO sessions (
    id,
    project_id,
    status,
    type,
    user_goal,
    project_context
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type CreateFilledSessionParams struct {
	ID             pgtype.UUID `json:"id"`
	ProjectID      pgtype.UUID `json:"project_id"`
	Status         string      `json:"status"`
	Type           pgtype.Text `json:"type"`
	UserGoal       pgtype.Text `json:"user_goal"`
	ProjectContext pgtype.Text `json:"project_context"`
}

func (q *Queries) CreateFilledSession(ctx context.Context, arg CreateFilledSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createFilledSession,
		arg.ID,
		arg.ProjectID,
		arg.Status,
		arg.Type,
		arg.UserGoal,
		arg.ProjectContext,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one
INSERT INTO sessions (
    id,
    status
) VALUES (
    $1, $2
) RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type CreateSessionParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession, arg.ID, arg.Status)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions
WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at FROM sessions
WHERE id = $1
`

func (q *Queries) GetSessionByID(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetSessionIteration = `-- name: ResetSessionIteration :one
UPDATE sessions
SET current_iteration = current_iteration - 1,
    updated_at = NOW()
WHERE id = $1
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

func (q *Queries) ResetSessionIteration(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, resetSessionIteration, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionIteration = `-- name: UpdateSessionIteration :one
UPDATE sessions
SET current_iteration = current_iteration + 1,
    updated_at = NOW()
WHERE id = $1
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

func (q *Queries) UpdateSessionIteration(ctx context.Context, id pgtype.UUID) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionIteration, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionProjectContext = `-- name: UpdateSessionProjectContext :one
UPDATE sessions
SET project_context = $1, 
    project_id = NULL, 
    updated_at = NOW()
WHERE id = $2
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type UpdateSessionProjectContextParams struct {
	ProjectContext pgtype.Text `json:"project_context"`
	ID             pgtype.UUID `json:"id"`
}

func (q *Queries) UpdateSessionProjectContext(ctx context.Context, arg UpdateSessionProjectContextParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionProjectContext, arg.ProjectContext, arg.ID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionRAGProjectContext = `-- name: UpdateSessionRAGProjectContext :one
UPDATE sessions
SET project_context = $1, 
    project_id = $3, 
    updated_at = NOW()
WHERE id = $2
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type UpdateSessionRAGProjectContextParams struct {
	ProjectContext pgtype.Text `json:"project_context"`
	ID             pgtype.UUID `json:"id"`
	ProjectID      pgtype.UUID `json:"project_id"`
}

func (q *Queries) UpdateSessionRAGProjectContext(ctx context.Context, arg UpdateSessionRAGProjectContextParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionRAGProjectContext, arg.ProjectContext, arg.ID, arg.ProjectID)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionResult = `-- name: UpdateSessionResult :one
UPDATE sessions
SET status = $2,
    result = $3,
    error = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type UpdateSessionResultParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
	Result pgtype.Text `json:"result"`
	Error  pgtype.Text `json:"error"`
}

func (q *Queries) UpdateSessionResult(ctx context.Context, arg UpdateSessionResultParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionResult,
		arg.ID,
		arg.Status,
		arg.Result,
		arg.Error,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionStatus = `-- name: UpdateSessionStatus :one
UPDATE sessions
SET status = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type UpdateSessionStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateSessionStatus(ctx context.Context, arg UpdateSessionStatusParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionStatus, arg.ID, arg.Status)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionType = `-- name: UpdateSessionType :one
UPDATE sessions
SET type = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type UpdateSessionTypeParams struct {
	ID   pgtype.UUID `json:"id"`
	Type pgtype.Text `json:"type"`
}

func (q *Queries) UpdateSessionType(ctx context.Context, arg UpdateSessionTypeParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionType, arg.ID, arg.Type)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSessionUserGoal = `-- name: UpdateSessionUserGoal :one
UPDATE sessions
SET user_goal = $2,
    updated_at = NOW()
WHERE id = $1
RETURNING id, project_id, status, type, user_goal, project_context, current_iteration, result, error, created_at, updated_at
`

type UpdateSessionUserGoalParams struct {
	ID       pgtype.UUID `json:"id"`
	UserGoal pgtype.Text `json:"user_goal"`
}

func (q *Queries) UpdateSessionUserGoal(ctx context.Context, arg UpdateSessionUserGoalParams) (Session, error) {
	row := q.db.QueryRow(ctx, updateSessionUserGoal, arg.ID, arg.UserGoal)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Status,
		&i.Type,
		&i.UserGoal,
		&i.ProjectContext,
		&i.CurrentIteration,
		&i.Result,
		&i.Error,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
