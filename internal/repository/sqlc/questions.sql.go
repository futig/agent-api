// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: questions.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO iteration_questions (
    id,
    iteration_id,
    question_number,
    status,
    question,
    explanation
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING id, iteration_id, question_number, status, question, explanation, answer, created_at, answered_at
`

type CreateQuestionParams struct {
	ID             pgtype.UUID `json:"id"`
	IterationID    pgtype.UUID `json:"iteration_id"`
	QuestionNumber int32       `json:"question_number"`
	Status         string      `json:"status"`
	Question       string      `json:"question"`
	Explanation    string      `json:"explanation"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (IterationQuestion, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.ID,
		arg.IterationID,
		arg.QuestionNumber,
		arg.Status,
		arg.Question,
		arg.Explanation,
	)
	var i IterationQuestion
	err := row.Scan(
		&i.ID,
		&i.IterationID,
		&i.QuestionNumber,
		&i.Status,
		&i.Question,
		&i.Explanation,
		&i.Answer,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

type CreateQuestionsParams struct {
	ID             pgtype.UUID `json:"id"`
	IterationID    pgtype.UUID `json:"iteration_id"`
	QuestionNumber int32       `json:"question_number"`
	Status         string      `json:"status"`
	Question       string      `json:"question"`
	Explanation    string      `json:"explanation"`
}

const getQuestionByID = `-- name: GetQuestionByID :one
SELECT id, iteration_id, question_number, status, question, explanation, answer, created_at, answered_at FROM iteration_questions
WHERE id = $1
`

func (q *Queries) GetQuestionByID(ctx context.Context, id pgtype.UUID) (IterationQuestion, error) {
	row := q.db.QueryRow(ctx, getQuestionByID, id)
	var i IterationQuestion
	err := row.Scan(
		&i.ID,
		&i.IterationID,
		&i.QuestionNumber,
		&i.Status,
		&i.Question,
		&i.Explanation,
		&i.Answer,
		&i.CreatedAt,
		&i.AnsweredAt,
	)
	return i, err
}

const getUnansweredQuestions = `-- name: GetUnansweredQuestions :many
SELECT iq.id, iq.iteration_id, iq.question_number, iq.status, iq.question, iq.explanation, iq.answer, iq.created_at, iq.answered_at FROM iteration_questions iq
JOIN session_iterations si ON si.id = iq.iteration_id
WHERE si.session_id = $1
  AND (iq.status = 'UNANSWERED' OR iq.status = 'SKIPED')
ORDER BY si.iteration_number ASC, iq.question_number ASC
`

func (q *Queries) GetUnansweredQuestions(ctx context.Context, sessionID pgtype.UUID) ([]IterationQuestion, error) {
	rows, err := q.db.Query(ctx, getUnansweredQuestions, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IterationQuestion{}
	for rows.Next() {
		var i IterationQuestion
		if err := rows.Scan(
			&i.ID,
			&i.IterationID,
			&i.QuestionNumber,
			&i.Status,
			&i.Question,
			&i.Explanation,
			&i.Answer,
			&i.CreatedAt,
			&i.AnsweredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsByIteration = `-- name: ListQuestionsByIteration :many
SELECT id, iteration_id, question_number, status, question, explanation, answer, created_at, answered_at FROM iteration_questions
WHERE iteration_id = $1
ORDER BY question_number ASC
`

func (q *Queries) ListQuestionsByIteration(ctx context.Context, iterationID pgtype.UUID) ([]IterationQuestion, error) {
	rows, err := q.db.Query(ctx, listQuestionsByIteration, iterationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IterationQuestion{}
	for rows.Next() {
		var i IterationQuestion
		if err := rows.Scan(
			&i.ID,
			&i.IterationID,
			&i.QuestionNumber,
			&i.Status,
			&i.Question,
			&i.Explanation,
			&i.Answer,
			&i.CreatedAt,
			&i.AnsweredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuestionsBySession = `-- name: ListQuestionsBySession :many
SELECT iq.id, iq.iteration_id, iq.question_number, iq.status, iq.question, iq.explanation, iq.answer, iq.created_at, iq.answered_at FROM iteration_questions iq
JOIN session_iterations si ON si.id = iq.iteration_id
WHERE si.session_id = $1
ORDER BY si.iteration_number ASC, iq.question_number ASC
`

func (q *Queries) ListQuestionsBySession(ctx context.Context, sessionID pgtype.UUID) ([]IterationQuestion, error) {
	rows, err := q.db.Query(ctx, listQuestionsBySession, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IterationQuestion{}
	for rows.Next() {
		var i IterationQuestion
		if err := rows.Scan(
			&i.ID,
			&i.IterationID,
			&i.QuestionNumber,
			&i.Status,
			&i.Question,
			&i.Explanation,
			&i.Answer,
			&i.CreatedAt,
			&i.AnsweredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const skipQustion = `-- name: SkipQustion :exec
UPDATE iteration_questions
SET status = 'SKIPED'
WHERE id = $1 AND status = 'UNANSWERED'
`

func (q *Queries) SkipQustion(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, skipQustion, id)
	return err
}

const updateQuestionAnswer = `-- name: UpdateQuestionAnswer :exec
UPDATE iteration_questions
SET answer = $2,
    status = 'ANSWERED',
    answered_at = NOW()
WHERE id = $1
`

type UpdateQuestionAnswerParams struct {
	ID     pgtype.UUID `json:"id"`
	Answer pgtype.Text `json:"answer"`
}

func (q *Queries) UpdateQuestionAnswer(ctx context.Context, arg UpdateQuestionAnswerParams) error {
	_, err := q.db.Exec(ctx, updateQuestionAnswer, arg.ID, arg.Answer)
	return err
}
